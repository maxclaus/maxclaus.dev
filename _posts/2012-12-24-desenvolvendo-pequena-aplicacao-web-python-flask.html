---
layout: post
title: Desenvolvendo uma pequena aplicação web com Python e Flask
categories:
- Python
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  _wp_old_slug: desenvolvendo-pequena-aplicao-web-python-flask
  _aioseop_keywords: python, flask, sqlalchemy, sqlite3, pythonanywhere, deploy, wsgi
  _aioseop_description: Neste artigo será explicado como configurar o seu ambiente
    de desenvolvimento, desenvolver uma aplicação web em python modularizada e no
    final publicá-la em um servidor free
  _aioseop_title: Desenvolvendo uma pequena aplicação web com Python e Flask
  simplecatch-sidebarlayout: ''
author:
  login: maxcnunes
  email: maxcnunes@gmail.com
  display_name: maxcnunes
  first_name: ''
  last_name: ''
---

<p>Neste artigo será explicado como configurar o seu ambiente de desenvolvimento, desenvolver uma aplicação web em python modularizada e no final publicá-la em um servidor free.</p>

<img class="size-full wp-image-836" title="Python-Code" src="/assets/Python-Code.png" alt="" width="480" height="333" />

<p><!--more--></p>
<p>Tópicos abordados:</p>
<ul>
<li><a href="#virtualenv">Virtualenv – Ambientes Virtuais Independentes</a></li>
<li><a href="#flask">Flask – Micro Framework de desenvolvimento web para Python</a></li>
<li><a href="#pythonanywhere">Python Any Where – Publicando de maneira simples e rápida</a></li>
</ul>
<h2><a name="virtualenv"></a>O que é o Virtualenv?</h2>
<p><img style="display: block; float: none; margin-left: auto; margin-right: auto;" src="/assets/Virtualenv.jpg" alt="" /></p>
<p>Virtualenv é um software que permite a criação de ambientes virtuais com total independência dos outros ambientes criados no Virtualenv. Isso permite que cada ambiente tenha autonomia para instalar plug-ins e bibliotecas de forma que a configuração de um ambiente não impacte nos restantes. Um exemplo prático seria a possibilidade de ter várias versões do Python, diferente para cada projeto, instalado na mesma máquina.</p>
<h3>&nbsp;</h3>
<h3>Instalando o Virtualenv</h3>
<p>Para facilitar nossa vida vamos utilizar um módulo Python chamado <strong>easy_install</strong> que gerencia pacotes Python e possui ferramentas de instalação que realiza automaticamente download, build e instalação dos pacotes disponíveis (no quais são muitos).</p>
<pre class="brush: bash; toolbar: false">sudo easy_install virtualenv</pre>
<blockquote><p>Caso você não tenha o easy_install configurado em sua máquina ainda, execute o seguinte comando no Terminal:</p>
<div id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:2df1208b-85eb-4691-a492-53210d4979e4" class="wlWriterEditableSmartContent" style="margin: 0px; display: inline; float: none; padding: 0px;">
<pre class="brush: bash;">sudo apt-get install python-setuptools python-dev build-essential</pre>
</div>
</blockquote>
<p>A mensagem de sucesso deverá ser algo parecida com a seguinte:</p>
<pre class="brush: shell; toolbar: false">Searching for virtualenv 
Best match: virtualenv 1.8.4 
Adding virtualenv 1.8.4 to easy-install.pth file 
Installing virtualenv script to /usr/local/bin 
Installing virtualenv-2.7 script to /usr/local/bin

Using /usr/local/lib/python2.7/dist-packages 
Processing dependencies for virtualenv 
Finished processing dependencies for virtualenv</pre>
<h3>&nbsp;</h3>
<h3>Criando o Primeiro Ambiente Virtual</h3>
<p>Antes de criar o primeiro ambiente virtual vamos separar um diretório para centralizar todos os documentos, códigos-fontes, configurações e outros assuntos relacionados a Desenvolvimento em um diretório chamado Development na Home do seu usuário no Linux:</p>
<pre class="brush: bash; toolbar: false">cd ~/
mkdir Development</pre>
<p>Para manter os ambientes virtuais bem organizados, vamos criar um diretório chamado virtualenvs dentro de Development:</p>
<pre class="brush: bash; toolbar: false">cd ~/Development
mkdir virtualenvs</pre>
<p>Agora sim vamos criar nosso primeiro ambiente virtual dentro do diretório virtualenvs. Como mais pra frente nesse post irei explicar como desenvolver uma pequena aplicação, esse ambiente virtual será focado para esse projeto. Então meu ambiente virtual se chamará i-sweated-yesterday:</p>
<pre class="brush: bash; toolbar: false">cd virtualenvs
virtualenv i-sweated-yesterday</pre>
<p>A mensagem de sucesso deverá ser algo parecida com a seguinte:</p>
<pre class="brush: bash; toolbar: false">New python executable in i-sweated-yesterday/bin/python 
Installing setuptools............done. 
Installing pip...............done. </pre>
<blockquote><p>Caso você desejasse criar um ambiente que não utilize qualquer biblioteca pré instalada no sistema operacional, deveria ser executado da forma a baixo:</p>
<pre class="brush: bash; toolbar: false">virtualenv i-sweated-yesterday --no-site-packages</pre>
</blockquote>
<h3>&nbsp;</h3>
<h3>Utilizando o Ambiente Virtual Criado</h3>
<h4>Ativando</h4>
<p>Para utilizar o ambiente virtual você deve ativá-lo antes de realizar qualquer configuração, como instalar ou utilizar alguma biblioteca instalada no mesmo. O comando para ativar o ambiente virtual criado anteriormente é o seguinte:</p>
<pre class="brush: bash; toolbar: false">source i-sweated-yesterday/bin/activate</pre>
<p>Sempre que o ambiente virtual estiver ativado irá exibir o nome do ambiente virtual no lado esquerdo das linhas de comando no Terminal (Prompt). No meu caso fica da seguinte forma:</p>
<pre class="brush: bash; toolbar: false">(i-sweated-yesterday)max@Max-Xub-VM:~$</pre>
<p>A partir de agora qualquer configuração realizada estará associada apenas ao ambiente virtual ativo no momento.</p>
<h4>Desativando</h4>
<p>Quando não existir mais a necessidade de utilizar o ambiente virtual no momento, você pode voltar para o ambiente do sistema operacional desativando o ambiente virtual atual:</p>
<pre class="brush: bash; toolbar: false">(i-sweated-yesterday)max@Max-Xub-VM:~$ deactivate </pre>
<h4>&nbsp;</h4>
<h4>Visualizar os Pacotes Instalados no Ambiente Virtual Atual</h4>
<p>Com o ambiente virtual ativado vamos instalar o pacote chamado yolk, que possui a funcionalidade de listar os pacotes já instalados no ambiente atual:</p>
<pre class="brush: bash; toolbar: false">sudo easy_install yolk</pre>
<p>Após instalado execute o seguinte comando para visualizar os pacotes instalados:</p>
<pre class="brush: bash; toolbar: false">yolk -l</pre>
<h2><a name="flask"></a>O que é o Flask?</h2>
<p><img style="display: block; float: none; margin-left: auto; margin-right: auto;" src="/assets/Flask.jpg" alt="" /></p>
<p>Flask é um micro framework de desenvolvimento web para Python baseado em duas bibliotecas externas: O Jinja2 e o Werkzeug. Por mais que seja considerado “micro”, Flask suporta extensões de diversas funcionalidades para a sua aplicação, como integração de ORM, validação de formulários, open autenticações e outras diversas extensões.</p>
<h3>&nbsp;</h3>
<h3>Configurações</h3>
<h4>Instalando o Flask</h4>
<p>Para utilizar o Flask precisamos instalá-lo primeiro (não esqueça de ativar o ambiente virtual antes):</p>
<pre class="brush: bash; toolbar: false">pip install Flask</pre>
<p>Vamos aproveitar que estamos instalando o Flask e já vamos instalar alguns outros pacotes para estender as funcionalidades do Flask e deixar o ambiente configurado para nosso aplicativo.</p>
<h4>Instalando SQLAlchemy</h4>
<p>SQLAlchemy é uma poderosa ferramenta ORM que possibilita aos desenvolvedores trabalhar com dados armazenados no banco de dados de maneira flexível e simplificada.</p>
<pre class="brush: bash; toolbar: false">pip install SQLAlchemy</pre>
<h4>&nbsp;</h4>
<h4>Instalando o Flask-SQLAlchemy</h4>
<p>Flask-SQLAlchemy adiciona funcionalidades ao Flask que facilitam algumas tarefas comuns ao utilizar o SQLAlchemy.</p>
<pre class="brush: bash; toolbar: false">pip install flask-sqlalchemy </pre>
<h3>&nbsp;</h3>
<h4>Instalando o Flask-WTF</h4>
<p>Flask-WTF integra de maneira simples o WTForms ao Flask, fornecendo uma maneira fácil de lidar com a apresentação de dados do usuário.</p>
<pre class="brush: bash; toolbar: false">pip install Flask-WTF</pre>
<h4>Instalando o SQLite3</h4>
<p>SQLite é um pacote que disponibiliza um Sistema Gerenciador de Banco de Dados Relacional e permite ser executado através de linha de comando, possibilitando executar qualquer query SQL básica de maneira simples. (Nossa aplicação não dependerá desse pacote para ser executada, mas seria bom já instalá-lo caso surja a necessidade de executar alguma query SQL no banco)</p>
<div id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:dfd4f07a-d3b0-4e0e-a732-f51a11bc6cfa" class="wlWriterEditableSmartContent" style="margin: 0px; display: inline; float: none; padding: 0px;">
<pre class="brush: bash;">sudo apt-get install sqlite3 libsqlite3-dev</pre>
</div>
<h3>Criando uma Aplicação Flask para Teste</h3>
<p>Antes de continuar com a nossa aplicação vamos criar uma aplicação em Flask o mais simples possível, apenas para verificar se o Flask foi instalado corretamente e está funcionando da maneira esperada.</p>
<p>Crie um arquivo chamado hello.py em qualquer diretório dentro de ~/Development:</p>
<pre class="brush: python; toolbar: false"># Importa biblioteca Flask
from flask import Flask

# Inicializa a aplicacao instanciando Flask
app = Flask(__name__)

# Atribui uma rota ao hello_world
@app.route('/')
def hello_world():
	return 'Hello World!'

# Roda a aplicacao em: http://localhost:8085
app.run(debug=True,port=8085)</pre>
<p>Os parâmetros debug e port são opcionais mas facilita muito que o debug esteja ativado para visualizar erros que ocorram durante a codificação e utilizando uma porta diferente do padrão 80 possibilita que você rode mais de uma aplicação ao mesmo tempo sem ocorrer o conflito de portas.</p>
<blockquote><p><strong>Definição do __name__</strong> :</p>
<ul>
<li>Se o módulo é executado diretamente o __name__ é __main__</li>
<li>Se o módulo é importado por outro módulo então __name__ é o nome do próprio módulo</li>
</ul>
</blockquote>
<p>Com o virtualenv ativado, rode a linha de comando a baixo e em seguida abra o navegador no endereço “http://localhost:8085 ”:</p>
<pre class="brush: bash; toolbar: false">python hello.py</pre>
<p>Caso esteja tudo correto então você deverá visualizar uma página com a mensagem “Hello World”.</p>
<h3>Desenvolvendo a Aplicação “I Sweated Yesterday”</h3>
<h4>I Sweated Yesterday</h4>
<p>É uma aplicação pequena e simples para controlar a frequência&nbsp; de dias que um usuário realiza exercícios físicos. É chamado “Yesterday” porque na empresa em que trabalho, sempre marcamos o exercício físico ao chegarmos na empresa no dia seguinte. Foi baseada na aplicação exemplificada por Armin Ronacher&nbsp;nesta <a href="https://github.com/mitsuhiko/flask/wiki/Large-app-how-to" target="_blank">página no Github</a>.</p>
<blockquote><p>O código fonte da versão dessa aplicação&nbsp;exemplificada nesse post está disponível para download <a href="https://github.com/maxcnunes/i-sweated-yesterday/tree/v1.0">aqui</a>&nbsp;e a versão mais atual está <a href="https://github.com/maxcnunes/i-sweated-yesterday">aqui</a>, qual ainda darei mais alguns retoques.</p></blockquote>
<h4>Visão Geral da Estrutura do Projeto</h4>
<p>Minha dica aqui é que você crie os arquivos e diretórios abaixo para facilitar quando formos codificar ou faça o download do código fonte a cima.</p>
<h5>Diretório Base</h5>
<p><em>Possui arquivos comuns para toda aplicação</em></p>
<table class="table_post_max" border="1" cellspacing="1" cellpadding="1">
<tbody>
<tr>
<td colspan="2" align="center" valign="top" width="296">/i-sweated-yesterday</td>
</tr>
<tr>
<td valign="top" width="296">/i-sweated-yesterday/initialize-db.py</td>
<td valign="top" width="293">Configurações para inicializar o banco de dados</td>
</tr>
<tr>
<td valign="top" width="296">/i-sweated-yesterday/config.py</td>
<td valign="top" width="293">Variáveis globais da aplicação</td>
</tr>
<tr>
<td valign="top" width="296">/i-sweated-yesterday/app.db</td>
<td valign="top" width="293">Arquivo de banco de dados</td>
</tr>
<tr>
<td valign="top" width="296">/i-sweated-yesterday/run.py</td>
<td valign="top" width="293">Roda a aplica cação</td>
</tr>
</tbody>
</table>
<h5>Diretório da Aplicação</h5>
<p><em>Possui o arquivo main, responsável por toda aplicação </em>&nbsp;</p>
<table class="table_post_max" border="1" cellspacing="1" cellpadding="1">
<tbody>
<tr>
<td colspan="2" align="center" valign="top" width="302">/i-sweated-yesterday/app</td>
</tr>
<tr>
<td valign="top" width="302">/i-sweated-yesterday/app/__init__.py</td>
<td valign="top" width="288">Faz com que o Python trate o diretório como um módulo, realiza a inicialização do Flask, SQLAlchemy e realiza a configuração de rotas básicas</td>
</tr>
</tbody>
</table>
<h5>Diretório – Módulo Users</h5>
<p><em>Possui arquivos relacionados ao módulo Users, como formulários, classes modelos (entidade/mapeamento banco), páginas htmls…</em></p>
<table class="table_post_max" border="1" cellspacing="1" cellpadding="1">
<tbody>
<tr>
<td colspan="2" align="center" valign="top" width="275">/i-sweated-yesterday/app/users</td>
</tr>
<tr>
<td valign="top" width="275">/i-sweated-yesterday/app/users/__init__.py</td>
<td valign="top" width="315">Faz com que o Python trate o diretório como um módulo</td>
</tr>
<tr>
<td valign="top" width="275">/i-sweated-yesterday/app/users/views.py</td>
<td valign="top" width="315">Onde será tratado as requisições (Similar a Controller no MVC)</td>
</tr>
<tr>
<td valign="top" width="275">/i-sweated-yesterday/app/users/forms.py</td>
<td valign="top" width="315">Definição formulários</td>
</tr>
<tr>
<td valign="top" width="275">/i-sweated-yesterday/app/users/constants.py</td>
<td valign="top" width="315">Definição de variáveis Constantes</td>
</tr>
<tr>
<td valign="top" width="275">/i-sweated-yesterday/app/users/models.py</td>
<td valign="top" width="315">Definição de Modelos</td>
</tr>
<tr>
<td valign="top" width="275">/i-sweated-yesterday/app/users/decorators.py</td>
<td valign="top" width="315">Definição de Decorators</td>
</tr>
<tr>
<td valign="top" width="275">/i-sweated-yesterday/app/users/requests.py</td>
<td valign="top" width="315">Definição de Requisições Comuns</td>
</tr>
</tbody>
</table>
<h5>Diretório – Módulo Exercises</h5>
<p><em>Possui arquivos relacionados ao módulo Exercises, como formulários, classes modelos (entidade/mapeamento banco), páginas htmls…</em></p>
<table class="table_post_max" border="1" cellspacing="1" cellpadding="1">
<tbody>
<tr>
<td colspan="2" align="center" valign="top" width="295">/i-sweated-yesterday/app/exercises</td>
</tr>
<tr>
<td valign="top" width="295">/i-sweated-yesterday/app/exercises/__init__.py</td>
<td valign="top" width="295">Faz com que o Python trate o diretório como um módulo</td>
</tr>
<tr>
<td valign="top" width="295">/i-sweated-yesterday/app/exercises/helpers.py</td>
<td valign="top" width="295">Definição de algumas funções uteis</td>
</tr>
<tr>
<td valign="top" width="295">/i-sweated-yesterday/app/exercises/views.py</td>
<td valign="top" width="295">Onde será tratado as requisições (Similar a Controller no MVC)</td>
</tr>
<tr>
<td valign="top" width="295">/i-sweated-yesterday/app/exercises/forms.py</td>
<td valign="top" width="295">Definição formulários</td>
</tr>
<tr>
<td valign="top" width="295">/i-sweated-yesterday/app/exercises/constants.py</td>
<td valign="top" width="295">Definição de variáveis Constantes</td>
</tr>
<tr>
<td valign="top" width="295">/i-sweated-yesterday/app/exercises/models.py</td>
<td valign="top" width="295">Definição de Modelos</td>
</tr>
</tbody>
</table>
<h5>Diretório Static</h5>
<p><em>Possui arquivos estáticos como css, imagens&nbsp; e javascripts</em></p>
<table class="table_post_max" border="1" cellspacing="1" cellpadding="1">
<tbody>
<tr>
<td colspan="2" align="center" valign="top" width="295">/i-sweated-yesterday/app/static</td>
</tr>
<tr>
<td valign="top" width="295">/i-sweated-yesterday/app/static/css</td>
<td valign="top" width="295">&nbsp;</td>
</tr>
<tr>
<td valign="top" width="295">/i-sweated-yesterday/app/static/css/reset.css</td>
<td valign="top" width="295">&nbsp;</td>
</tr>
<tr>
<td valign="top" width="295">/i-sweated-yesterday/app/static/css/main.css</td>
<td valign="top" width="295">&nbsp;</td>
</tr>
<tr>
<td valign="top" width="295">/i-sweated-yesterday/app/static/js</td>
<td valign="top" width="295">&nbsp;</td>
</tr>
<tr>
<td valign="top" width="295">/i-sweated-yesterday/app/static/js/main.js</td>
<td valign="top" width="295">&nbsp;</td>
</tr>
<tr>
<td valign="top" width="295">/i-sweated-yesterday/app/static/img</td>
<td valign="top" width="295">&nbsp;</td>
</tr>
</tbody>
</table>
<h5>Diretório Templates</h5>
<p><em>Possui arquivos de templates, ou seja, todas as páginas htmls puras ou com definições Jinja2</em></p>
<table class="table_post_max" border="1" cellspacing="1" cellpadding="1">
<tbody>
<tr>
<td colspan="2" align="center" valign="top" width="332">/i-sweated-yesterday/app/templates</td>
</tr>
<tr>
<td valign="top" width="332">/i-sweated-yesterday/app/templates/base.html</td>
<td valign="top" width="258">&nbsp;</td>
</tr>
<tr>
<td valign="top" width="332">/i-sweated-yesterday/app/templates/users</td>
<td valign="top" width="258">&nbsp;</td>
</tr>
<tr>
<td valign="top" width="332">/i-sweated-yesterday/app/templates/users/register.html</td>
<td valign="top" width="258">&nbsp;</td>
</tr>
<tr>
<td valign="top" width="332">/i-sweated-yesterday/app/templates/users/profile.html</td>
<td valign="top" width="258">&nbsp;</td>
</tr>
<tr>
<td valign="top" width="332">/i-sweated-yesterday/app/templates/users/login.html</td>
<td valign="top" width="258">&nbsp;</td>
</tr>
<tr>
<td valign="top" width="332">/i-sweated-yesterday/app/templates/forms</td>
<td valign="top" width="258">&nbsp;</td>
</tr>
<tr>
<td valign="top" width="332">/i-sweated-yesterday/app/templates/forms/macros.html</td>
<td valign="top" width="258">&nbsp;</td>
</tr>
<tr>
<td valign="top" width="332">/i-sweated-yesterday/app/templates/404.html</td>
<td valign="top" width="258">&nbsp;</td>
</tr>
<tr>
<td valign="top" width="332">/i-sweated-yesterday/app/templates/exercises</td>
<td valign="top" width="258">&nbsp;</td>
</tr>
<tr>
<td valign="top" width="332">/i-sweated-yesterday/app/templates/exercises/i_did.html</td>
<td valign="top" width="258">&nbsp;</td>
</tr>
</tbody>
</table>
<h4>Configuração</h4>
<p>O arquivo <strong>run.py</strong> será utilizando durante o desenvolvimento para inicializar a aplicação e disponibilizar o acesso pelo browser no endereço <a href="http://localhost:8090">http://localhost:8090</a>:</p>
<pre class="brush: python; toolbar: false">from app import app as application
application.run(debug=True,port=8090)</pre>
<p>O arquivo <strong>config.py</strong> será utilizado para definição de valores comuns de toda aplicação. Mantendo essas informações centralizadas nesse arquivo facilitará durante a publicação para o ambiente de produção ou de testes, que essas informações sejam alteradas de acordo com a necessita de cada ambiente:</p>
<pre class="brush: python;">import os

_basedir = os.path.abspath(os.path.dirname(__file__))

DEBUG = False

ADMINS = frozenset(['youremail@yourdomain.com'])
SECRET_KEY = 'SECRET_KEY_FOR_SESSION_SIGNING'

# Define the path of our database inside the root application, 
# where 'app.db' is the database's name
SQLALCHEMY_DATABASE_URI = 'sqlite:///' + os.path.join(_basedir, 'app.db')
DATABASE_CONNECT_OPTION = {}

THREADS_PER_PAGE = 8

CSRF_ENABLED = True
CSRF_SESSION_KEY = 'SOMETHING_IMPOSSIBLE_TO_GUEES'</pre>
<blockquote><p><strong>_basedir</strong> : mantém o caminho de onde os scripts são executados</p>
<p><strong>DEBUG</strong> : utilizado como <em>True</em> em ambientes de desenvolvimento, permite que seja exibido detalhadamente a requisição, caso ocorra algum erro durante o processo</p>
<p><strong>SECRET_KEY</strong> : utilizado na criação dos cookies</p>
<p><strong>ADMINS</strong> : email do Administrador responsável pelo site</p>
<p><strong>SQLALCHEMY_DATABASE_URI</strong> e <strong>DATABASE_CONNECT_OPTIONS</strong> : opções de conexão do SQLAlchemy</p>
<p><strong>CSRF_ENABLED</strong> e <strong>CSRF_SESSION_KEY</strong> : proteção contra fraude de posts</p></blockquote>
<p>O arquivo <strong>initialize-db.py</strong> será utilizado para criar a estrutura de tabelas que iremos configurar mais adiante em nossas Models:</p>
<pre class="brush: python">from app import db

# Drop all tables from db file
db.drop_all() 

# Create all tables on db file,
# copying the structure from the definition on the Models
db.create_all()</pre>
<h4>Main</h4>
<p>O arquivo <strong>__init__.py</strong> será o main da aplicação, nele estará a definição do Flask, SQLAlchemy e as rotas comuns:</p>
<pre class="brush: python; wrap-lines:false">from flask import Flask, render_template, redirect, url_for
from flask.ext.sqlalchemy import SQLAlchemy

app = Flask(__name__)
app.config.from_object('config')

db = SQLAlchemy(app)


# Basic Routes #

@app.route('/')
def index():
	return redirect(url_for('users.index'))

@app.errorhandler(404)
def not_found(error):
	return render_template('404.html'), 404


# BluePrints - Modules #

# Users Module
from app.users.views import mod as usersModule
app.register_blueprint(usersModule)

# Exercises Module
from app.exercises.views import mod as exercisesModule
app.register_blueprint(exercisesModule)</pre>
<blockquote><p><strong>Blueprint</strong> basicamente permite que um módulo estenda a aplicação principal e funcione similarmente a aplicação Flask. Sendo esta uma das grandes vantagem para aplicações maiores, por permitir a modularização de uma aplicação, o que facilita em muito a organização, desenvolvimento e manutenções do código fonte.</p>
<p>Veja mais sobre <a href="http://flask.pocoo.org/docs/blueprints/">Blueprints</a>.</p></blockquote>
<h4>Módulo Usuário</h4>
<p>Como este será um módulo estendido da aplicação principal, o nosso arquivo <strong>__init__.py</strong> estará vazio, pois objetos que precisamos já foram inicializados pela Main.</p>
<p>O arquivo <strong>constants.py</strong> é simples e contêm apenas valores Constantes, centralizados todos no mesmo arquivo para priorizar a organização e facilitar caso surja a necessidade de alguma manutenção futura:</p>
<pre class="brush: python;wrap-lines:false;"># User role
ADMIN = 0
STAFF = 1
USER = 2
ROLE = {
	ADMIN: 'admin',
	STAFF: 'staff',
	USER: 'user',
}

# User status
INACTIVE = 0
NEW = 1
ACTIVE = 2
STATUS = {
	INACTIVE: 'inactive',
	NEW: 'new',
	ACTIVE: 'active',
}

# Session Name
SESSION_NAME_USER_ID = 'user_id'</pre>
<p>O <strong>models.py</strong> contém a definição da model User, sendo basicamente estruturada pela definições de propriedades, mapeamentos model/database, construtores da classe e métodos GET e SET:</p>
<pre class="brush: python;wrap-lines:false;"># third party imports
from sqlalchemy.sql import extract, func

# local application imports
from app import db
from app.users import constants as USER
from app.exercises.models import Exercise
from app.exercises.helpers import DateHelper



class User(db.Model):
	# Map model to db table
	id = db.Column(db.Integer, primary_key=True)
	name = db.Column(db.String(50), unique=True)
	email = db.Column(db.String(120), unique=True)
	password = db.Column(db.String(20))
	role = db.Column(db.SmallInteger, default=USER.USER)
	status = db.Column(db.SmallInteger, default=USER.NEW)
	exercises = db.relationship('Exercise', backref='user', lazy='dynamic')


	# Class Constructor
	def __init__(self, id=None):
		self.id = id


	# Factory Constructor of a new user to register
	@classmethod
	def NewUserToRegister(cls, name=None, email=None, password=None):
		_user = cls()
		_user.name = name
		_user.email = email
		_user.password = password
		return _user

	

	def getNameTitle(self):
		return self.name.title()


	def getStatus(self):
		return USER.STATUS[self.status]


	def getRole(self):
		return USER.ROLE[self.role]


	def getTotalExercises(self):
		return len(self.exercises.all())


	def getTotalExercisesCurrentWeek(self):

		start_end_week = DateHelper.get_start_end_days_current_week()
		start_week = start_end_week[0]
		end_week = start_end_week[1]

		return len(db.session.query(Exercise.id) 
						.filter(Exercise.user_id == self.id)
						.filter(Exercise.date >= start_week)
						.filter(Exercise.date <= end_week)
						.all())


	def getTotalExercisesCurrentMonth(self):

		current_month = DateHelper.current_month()

		return len(db.session.query(Exercise.id) 
						.filter(Exercise.user_id == self.id)
						.filter(extract('month', Exercise.date) == current_month)
						.all())


	def alreadyDidExerciseYesterday(self):

		yesterday = DateHelper.get_yesterday()

		return (len(db.session.query(Exercise.id) 
						.filter(Exercise.user_id == self.id)
						.filter(Exercise.date == yesterday)
						.all()) > 0)


	def __repr__():
		return '<User %r><user   %r>' % (self.name)</pre>
<p>O <strong>forms.py</strong>&nbsp; utiliza o módulo <em>WTForms</em> para gerar formulários de maneira fácil e simples, como campos associados a labels e propriedades <em>Required</em>, caso seja obrigatório:</p>
<pre class="brush: python;wrap-lines:false;">from flask.ext.wtf import Form, TextField, PasswordField, BooleanField
from flask.ext.wtf import Required, Email, EqualTo

class LoginForm(Form):
	email = TextField('Email address', [Required(), Email()])
	password = PasswordField('Password', [Required()])


class RegisterForm(Form):
	name = TextField('NickName', [Required()])
	email = TextField('Email address', [Required()])
	password = PasswordField('Password', [Required()])
	confirm = PasswordField('Repeat Password', [
		Required(),
		EqualTo('confirm', message='Passwords must match')
		])</pre>
<p>O <strong>decorators.py</strong> possui a declaração para o decorator requires_login, no qual verifica se o usuário está logado, caso não esteja redireciona o usuário para a página de login:</p>
<pre class="brush: python;wrap-lines:false;">from functools import wraps
from flask import g, flash, redirect, url_for, request

def requires_login(f):
	@wraps(f)
	def decorated_function(*args, **kwargs):
		if g.user is None:
			flash(u'You need to be signed in for this page.')
			return redirect(url_for('users.login', next=request.path))
		return f(*args, **kwargs)
	return decorated_function</pre>
<blockquote><p><strong>flask.g</strong> : é um objeto no Flask que possui a responsabilidade de armazenar e compartilhar dados através do tempo de execução de uma requisição</p>
<p><strong>*args</strong> : o <strong>*</strong> é utilizado para permitir que um parâmetro aceite um número não definido de argumentos para sua função (parecido com a keyword <em>params</em> no C#)</p>
<p><strong>**kwargs</strong> : Da mesma forma, <strong>**</strong> permite lidar com argumentos nomeados que não foram previamente definidos (parecido com a keyword <em>params+dictonary</em> no C#)</p></blockquote>
<p>O <strong>requests.py</strong> possui a declaração de uma função comum a várias páginas na aplicação. No qual se existir um usuário logado na requisição atual será recuperado o Id do usuário na sessão, então recupera-rá o objeto usuário no banco e será mantido até o final da requisição no objeto <strong>flask.g.user</strong>:</p>
<pre class="brush: python;wrap-lines:false;"># third party imports
from flask import g, session

# local application imports
from app.users.constants import SESSION_NAME_USER_ID
from app.users.models import User


def app_before_request():
	# pull user's profile from the db before every request are treated
	g.user = None
	if SESSION_NAME_USER_ID in session and session[SESSION_NAME_USER_ID] is not None:
		g.user = User.query.get(session[SESSION_NAME_USER_ID])</pre>
<p>O <strong>views.py</strong>, para quem está acostumado com MVC funciona como uma Controller, é onde será definido as requisições possíveis para esse módulo, associando as rotas existentes as funcionalidades específicas de cada uma. Como dito anteriormente esse módulo não será uma aplicação e sim um módulo estendido da aplicação principal. Então ao invés de utilizarmos um objeto do tipo <strong>Flask</strong>, como para a definição de rotas, iremos utilizar o <strong>Blueprint</strong>.</p>
<pre class="brush: python;wrap-lines:false;"># third party imports
from flask import Blueprint, request, render_template, flash, g, session, redirect, url_for
from werkzeug import check_password_hash, generate_password_hash
from datetime import datetime
from sqlalchemy.sql import or_


# local application imports
from app import db
from app.users.forms import RegisterForm, LoginForm
from app.users.models import User
from app.users.requests import app_before_request
from app.users.decorators import requires_login
from app.users.constants import SESSION_NAME_USER_ID
from app.exercises.models import Exercise


mod = Blueprint('users', __name__, url_prefix='/users')


@mod.before_request
def before_request():
	app_before_request()


@mod.route('/')
@mod.route('/me/')
@requires_login
def index():
	return render_template('users/profile.html', user=g.user)


@mod.route('/login/', methods=['GET', 'POST'])
def login():
	form = LoginForm(request.form)

	# make sure data are valid, but doesn't validate password is right
	if form.validate_on_submit():

		user = User.query.filter_by(email=form.email.data).first()

		# we use werzeug to validate user's password
		if user and check_password_hash(user.password, form.password.data):

			# the session can't be modified as it's signed,
			# it's a safe place to store the user id
			session[SESSION_NAME_USER_ID] = user.id

			flash('Welcome %s' % user.name)
			return redirect(url_for('users.index'))

		flash('Wrong email or password', 'error-message')

	return render_template( 'users/login.html', form=form)


@mod.route('/register/', methods=['GET', 'POST'])
def register():
	form = RegisterForm(request.form)

	if form.validate_on_submit():

		userRegistered = User.query.filter(or_(User.name == form.name.data,
							User.email == form.email.data)).first()
		
		if userRegistered is not None:
			flash('Email or user already is registered')
			return render_template('users/register.html', form=form)


		# create an user instance not yet stored in the database
		user = User.NewUserToRegister(form.name.data, form.email.data,
						generate_password_hash(form.password.data))

		# insert the record in our database and commit it
		db.session.add(user)

		db.session.commit()

		# log the user in, as he now has an id
		session[SESSION_NAME_USER_ID] = user.id

		# flash will display a message to the user
		flash('Thanks for registering')

		# redirect user to the 'index' method of the user module
		return redirect(url_for('users.index'))
	return render_template('users/register.html', form=form)


@mod.route('/logout/', methods=['GET'])
def logout():
	# remove the username from the session if it's there
	session.pop(SESSION_NAME_USER_ID, None)

	# flash will display a message to the user
	flash('Do not forget keep the exercises')

	# redirect user to the 'index' method of the user module
	return redirect(url_for('users.login'))</pre>
<blockquote><p><strong>validate_on_submit</strong> : função do WTForm, no qual verifica se o formulário é valido durante uma requisição do tipo POST ou PUT</p>
<p><strong>render_template</strong> : retorna um documento renderizado, no nosso caso todos html, de acordo com o arquivo template e o formulário passado</p>
<p><strong>flash</strong> : possibilita que mensagens declaradas na view sejam recuperadas no template e exibidas para o usuário</p>
<p><strong>@mod.route('/login/', methods=['GET', 'POST'])</strong>&nbsp; : associa uma rota a uma função que estiver após sua definição. O primeiro parâmetro define por qual caminho será executado e o segundo parâmetro quais os métodos REST serão aceitos por essa rota.</p></blockquote>
<h4>Templates</h4>
<p>Como Flask já possui integrado o Jinja, vamos utilizar em nossos templates algumas de suas funcionalidades disponíveis, como estruturas de condições, laços de repetições, blocos de conteúdos. Permitindo um alto nível de reutilização e fácil desenvolvimento.</p>
<p>O <strong>base.html</strong> será o template base, do qual será herdado pelos outros templates. Nesse template teremos a definição do corpo <em>HTML, HEAD, BODY</em> e blocos de conteúdo que poderão ser substituídos com outros conteúdos pelos templates que o herdarem.</p>
<div id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:c26cb131-b45d-458e-89e6-9f44f0cc52ba" class="wlWriterEditableSmartContent" style="margin: 0px; display: inline; float: none; padding: 0px;">
{% raw %}
<pre class="brush: html;wrap-lines:false;"><!DOCTYPE html SYSTEM>

<html>

	<head>

		<meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;" />

		<title>{% block title %}I Sweated Yesterday{% endblock %}</title>

		{% block css %}

		<link rel="stylesheet" href="/static/css/reset.css" />

		<link rel="stylesheet" href="/static/css/main.css" />

		{% endblock %}

		{% block script %}

		<script src="/static/js/main.js" type="text/javascript"></script>

		{% endblock %}

	</head>

	<body>

		<div id="wrapper">

			<div id="header">

				{% block header %}

				<h1>I Sweated Yesterday</h1>

				{% endblock %}

				

			</div>

			<div id="messages">

				{% for category, msg in get_flashed_messages(with_categories=true) %}

					
{{ msg }}
				{% endfor %}

			</div>

			<div id="content" class="shadow">

				{% block logout %}

				<a class="bt-action-logout" href="{{ url_for('users.logout') }}">

					Logout

				</a>

				{% endblock %}

				

				{% block content %}{% endblock %}</div>

			<div id="footer">{% block footer %}{% endblock %}</div>

		</div>

	</body>

</html>

</pre>
{% endraw %}
</div>{% raw %}
<p>O <strong>macros.html</strong> possuirá definições de macros. No nosso caso criamos um macro chamado <strong>render_field</strong> no qual será responsável por criar uma estrutura <em>HTML</em> para os campos dos nossos formulários. Um detalhe importante desse macro é que caso exista alguma validação que não tenha passado durante a execução do <em>validate_on_submit</em> na view, então as mensagens de erro serão adicionados no <em>HTML</em> gerado.</p>
<div id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:7e2ca7db-ada5-4e77-8ba1-1ba6608e1f6d" class="wlWriterEditableSmartContent" style="margin: 0px; display: inline; float: none; padding: 0px;">
{% raw %}
<pre class="brush: html;">{% macro render_field(field) %}

<div class="form_field">
<p> {{ field.label(class="label") }}</p>
<p> {% if field.errors %}</p>
<p>   {% set css_class = 'has_error' + kwargs.pop('class', '') %}</p>
<p>   {{ field(class=css_class, **kwargs) }}</p>
<ul class="errors">
<p>     {% for error in field.errors %}</p>
<li>{{ error|e }}</li>
<p>     {% endfor %}</p>
</ul>
<p> {% else %}</p>
<p>   {{ field(**kwargs) }}</p>
<p> {% endif %}</p></div>
<p>{% endmacro %}
</p></div>
	</pre>
{% endraw %}
<p>O <strong>register.html</strong> herda o base.html e substitui os blocos de conteúdo <em>logout, content e footer</em>. Este template será responsável pelo <em>HTML</em> utilizado no registro de um novo usuário, por isso o método utilizado é o POST e action referencia a url atual sem o nome da página, no qual se verificarmos na view estará apontando para a função <em>register</em>:</p>
{% raw %}
<div id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:2134c96f-a08a-4d4f-b4e6-fde949c56169" class="wlWriterEditableSmartContent" style="margin: 0px; display: inline; float: none; padding: 0px;">
<pre class="brush: html;">{% extends "base.html" %}



{% block logout %}<!-- remove btn logout -->{% endblock %}



{% block content %}

  {% from "forms/macros.html" import render_field %}
<form method="POST" action="." class="form">
<p>    {{ form.csrf_token }}</p>
<p>    {{ render_field(form.name, class="input text") }}</p>
<p>    {{ render_field(form.email, class="input text") }}</p>
<p>    {{ render_field(form.password, class="input text") }}</p>
<p>    {{ render_field(form.confirm, class="input text") }}</p>
<p>    <input type="submit" value="Register" class="button green" /></p></form>
<p>{% endblock %}</p>
<p>{% block footer %}</p>
<p>  <a class="bt-action bt-action-user" href="{{ url_for('users.login') }}"></p>
<p>    <span>Login</span></p>
<p>  </a></p>
<p>{% endblock %}
</p></div>
{% raw %}
<p>A partir de agora será melhor que você siga o resto da aplicação analisando e copiando direto do código fonte disponibilizado mais a cima nesse tutorial, se não este artigo irá ficar muito maior do que já está.</p>
<h4>Executando a Aplicação</h4>
<p>No primeiro momento que executarmos a aplicação é necessário inicializar o banco de dados, para isso abra o Terminal do sistema operacional, acesse o diretório da aplicação e execute a linha de comando a baixo (não esqueça de antes ativar o ambiente virtual):</p>
<div id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:7aa6c46b-eefe-4b69-8c89-ef760fd5b7e8" class="wlWriterEditableSmartContent" style="margin: 0px; display: inline; float: none; padding: 0px;">
<pre class="brush: bash;">python initialize-db.py</pre>
</div>
<p>Após executado a linha de comando a cima, só a execute novamente caso você deseje resetar o banco de dados, pois será criado as tabelas novamente e perderá todos os dados existentes.</p>
<p>Para inicializar a aplicação execute a linha de comando a baixo:</p>
<div id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:54a82fea-b4b8-4d26-a8f0-c7ca25410e1c" class="wlWriterEditableSmartContent" style="margin: 0px; display: inline; float: none; padding: 0px;">
<pre class="brush: bash;">python run.py</pre>
</div>
<p>Se a aplicação não possuir nenhuma falha grave será exibido a seguinte mensagem no Terminal:</p>
<div id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:a4cd22e2-9a41-445f-985d-36c52eb34608" class="wlWriterEditableSmartContent" style="margin: 0px; display: inline; float: none; padding: 0px;">
<pre class="brush: bash;"> * Running on http://127.0.0.1:8090/
 * Restarting with reloader</pre>
</div>
<p>Para visualizar a aplicação abra qualquer browser com a seguinte URL: <a title="http://127.0.0.1:8090/ " href="http://127.0.0.1:8090/">http://127.0.0.1:8090/</a>.</p>
<h2><a name="pythonanywhere"></a>O que é o Python Any Where?</h2>
<p><img style="display: block; float: none; margin-left: auto; margin-right: auto;" src="/assets/PythonAnywhere.png" alt="" /></p>
<p>O <a href="https://www.pythonanywhere.com" target="_blank">Python Any Where</a> é uma IDE online e serviço de hospedagem baseado em Python. No qual disponibiliza a hospedagem web de aplicações python e acesso ao um console online possibilitando desenvolvimento em python com várias bibliotecas disponíveis de maneira online, fácil e gratuita para o plano mais simples.</p>
<h3>Publicando</h3>
<ol>
<li>Crie um cadastro no Python Any Where</li>
<li>Selecione a opção <em><strong>I want to create a web application</strong></em></li>
<li>Selecione a aba <strong><em>Web</em></strong> e em seguida a opção <em><strong>Add a new web app</strong></em></li>
<li>Selecione <strong><em>Next</em></strong> na primeira janela</li>
<li>Selecione <strong><em>Flask</em></strong> para definir o Framework Web Python a ser utilizado</li>
<li>Selecione <strong><em>Next</em></strong> para confirmar o caminho físico da sua aplicação</li>
<li>Após criada a opção <em><strong>It is configured via WSGI file stored at</strong></em> para editar arquivo wsgi</li>
<li>Edite o arquivo wsgi, atualizando o valor da variável projec_home com o caminho físico correto da sua aplicação (abra a aba Files para confirmar o caminho correto) e na última linha certifique-se de estar realizando a importação correta, caso você tenha deixado a variável instanciado do Flask no arquivo __init__.py da aplicação como “app”, então você deixar a última linha da forma que está:<strong><em>/ &gt; var &gt; www &gt; YOUR-USER-NAME_pythonanywhere_com_wsgi.py</em> :</strong>
{% raw %}
<div id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:6365503e-d022-4e06-ad68-cde8abe28998" class="wlWriterEditableSmartContent" style="margin: 0px; display: inline; float: none; padding: 0px;">
<pre class="brush: python;"># This file contains the WSGI configuration required to serve up your
# web application at http://<your-username>.pythonanywhere.com/
# It works by setting the variable 'application' to a WSGI handler of some
# description.
#
# The below has been auto-generated for your Flask project

import sys

# add your project directory to the sys.path
project_home = u'/home/YOUR-USER-NAME/i-sweated-yesterday'
if project_home not in sys.path:
    sys.path = [project_home] + sys.path

# import flask app but need to call it "application" for WSGI to work
#from flask_app import app as application #example
from app import app as application</your-username></pre>
</div>
{% endraw %}
</li>
<li>Salve o arquivo anterior</li>
<li>Acesse a aba <strong>Files</strong> e em seguida o diretório : <strong><em>/ &gt; home &gt;&nbsp; YOUR-USER-NAME</em></strong></li>
<li>Clique no botão <strong>Escolher Arquivo</strong></li>
<li>Selecione o seu projeto compactado como .zip</li>
<li>Clique em Upload</li>
<li>Acesse a aba <strong>Consoles</strong> e selecione a opção <strong>Bash</strong></li>
<li>Execute o seguinte comando no console:
<div id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:a563e3c5-5ca5-4d46-a7fb-c33c9ca05d17" class="wlWriterEditableSmartContent" style="margin: 0px; display: inline; float: none; padding: 0px;">
<pre class="brush: bash;">unzip SEU-PROJETO-COMPACTADO.zip </pre>
</div>
</li>
<li>Para inicializar o banco de dados execute o seguinte comando no console:
<div id="scid:f32c3428-b7e9-4f15-a8ea-c502c7ff2e88:ab37ab78-0c71-458d-a388-9712e5b075ba" class="wlWriterEditableSmartContent" style="margin: 0px; display: inline; float: none; padding: 0px;">
<pre class="brush: bash;">python YOUR-PROJECT-DIRECTORY/initialize-db.py </pre>
</div>
</li>
<li>Acesse a aba Web e clique em <strong>Reload web app</strong></li>
<li>Finalmente para visualizar o aplicativo rodando clique no link <strong>You can see your web app at</strong> disponível na aba Web (caso ocorra algum erro ao abrir a aplicação, veja a descrição mais detalhada do problema nos logs de erros disponíveis também na aba Web)</li>
</ol>
<blockquote><p><strong>Wsgi</strong> (Web Server Gateway Interface): Define uma simples interface entre Servidores Web e Aplicações Web ou Frameworks para Python.</p>
<p><strong>Dica</strong> : Utilizamos a função de Upload para enviar o código fonte da nossa aplicação do computador local para o servidor web. Mas seria ainda mais fácil quando utilizado o Dropbox ou melhor ainda o Github. De uma olhada nisso, vai facilitar ainda mais o deploy quando realizado várias vezes.</p></blockquote>
